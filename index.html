<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Analysis</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>

  <!-- FontAwesome & Tailwind -->
  <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;700&display=swap" rel="stylesheet">

  <style>
    /* Custom CSS for trophy shaking animation */
    @keyframes shakeTrophy {
      0% { transform: rotate(0deg); }
      25% { transform: rotate(10deg); }
      50% { transform: rotate(-10deg); }
      75% { transform: rotate(10deg); }
      100% { transform: rotate(0deg); }
    }
    @keyframes shakeCross {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }
    @keyframes pulseWin {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
      70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
    }
    @keyframes pulseLoss {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
      70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }
    .trophy-shake {
      display: inline-block;
      animation: shakeTrophy 0.5s ease-in-out;
    }
    .cross-shake {
      display: inline-block;
      animation: shakeCross 0.5s ease-in-out;
    }
    .pulse-win {
      animation: pulseWin 1s ease;
    }
    .pulse-loss {
      animation: pulseLoss 1s ease;
    }

  </style>
</head>
<body class="bg-Lite green-100 font-['El_Messiri']">
  
  <div class="container mx-auto p-5">
    <h1 class="text-center text-3xl font-bold text-green-600">TKS AI PRO</h1>

    <!-- Period & Result Box -->
    <div class="bg-white p-4 rounded-lg shadow-md mt-4 text-center">
      <p class="text-lg font-semibold text-gray-700"><i class="fas fa-calendar-alt"></i> Period: <span id="period-number" class="text-black"></span></p>
      <p class="text-lg font-semibold text-lite blu-700"><i class="fas fa-chart-line"></i> Result: <span id="predicted-result" class="text-green-500 font-bold">Loading...</span></p>
      <div class="mt-2">
        <div class="accuracy-meter">
          <div id="accuracy-fill" class="accuracy-fill" style="width: 0%"></div>
        </div>
        <p class="text-sm text-gray-600 mt-1">AI Accuracy: <span id="accuracy-value">0%</span></p>
        <div class="confidence-indicator">
          <div id="confidence-fill" class="confidence-fill" style="width: 0%"></div>
        </div>
        <p class="text-xs text-gray-500">Confidence: <span id="confidence-value">0%</span></p>
      </div>
    </div>

    <!-- Analysis Section -->
    <div class="bg-white p-4 rounded-lg shadow-md mt-4">
      <h2 class="text-lg font-semibold text-gray-700 text-center">Analysis</h2>
      <div class="grid grid-cols-2 gap-4 mt-2">
        <div class="bg-green-50 p-3 rounded text-center">
          <p class="text-gray-600">Win Count</p>
          <p id="won-count" class="text-xl font-bold text-green-500">0</p>
        </div>
        <div class="bg-green-50 p-3 rounded text-center">
          <p class="text-gray-600">Loss Count</p>
          <p id="lost-count" class="text-xl font-bold text-red-500">0</p>
        </div>
        <div class="bg-green-50 p-3 rounded text-center">
          <p class="text-gray-600">Win %</p>
          <p id="won-percentage" class="text-xl font-bold text-green-500">0%</p>
        </div>
        <div class="bg-green-50 p-3 rounded text-center">
          <p class="text-gray-600">Streak</p>
          <p id="current-streak" class="text-xl font-bold text-gray-500">0</p>
        </div>
      </div>
    </div>

    <!-- Pattern Detection Section -->
    <div class="bg-white p-4 rounded-lg shadow-md mt-4">
      <h2 class="text-lg font-semibold text-gray-700 text-center">AI Analysis</h2>
      <div id="pattern-info" class="text-center text-sm text-gray-600 mt-2">
        Analyzing period patterns...
      </div>
      <div id="algorithm-info" class="text-center text-xs text-gray-500 mt-1">
        Using multi-factor predictive algorithm
      </div>
    </div>

    <!-- History Section -->
    <div class="bg-white p-4 rounded-lg shadow-md mt-4">
      <h2 class="text-lg font-semibold text-gray-700 text-center">History</h2>
      <div id="history-list" class="grid grid-cols-1 gap-1 mt-1"></div>
    </div>
  </div>

  <script>
  let previousResults = [];
  let latestResult = null;
  let latestPeriod = null;
  let storedHistory = JSON.parse(localStorage.getItem("gameHistory")) || [];
  let currentStreak = 0;
  let streakType = ''; // 'win' or 'loss'
  let totalPredictions = 0;
  let correctPredictions = 0;
  let currentConfidence = 0;

  // ✅ Enhanced AI Prediction Algorithm with Multiple Factors
  function predictBasedOnPeriod(periodNumber) {
    const periodStr = periodNumber.toString();
    const lastFour = periodStr.slice(-4);
    const digits = lastFour.split('').map(Number);
    
    // 1. Digit Sum Analysis
    const digitSum = digits.reduce((sum, digit) => sum + digit, 0);
    const digitSumMod3 = digitSum % 3;
    const digitSumMod5 = digitSum % 5;
    
    // 2. Digit Pattern Analysis
    const evenDigits = digits.filter(d => d % 2 === 0).length;
    const oddDigits = digits.filter(d => d % 2 !== 0).length;
    const ascendingCount = digits.filter((d, i) => i > 0 && d > digits[i-1]).length;
    const descendingCount = digits.filter((d, i) => i > 0 && d < digits[i-1]).length;
    
    // 3. Positional Analysis
    const firstLastDiff = Math.abs(digits[0] - digits[3]);
    const middleAvg = (digits[1] + digits[2]) / 2;
    
    // 4. Historical Pattern Matching (simple version)
    const lastTwoDigits = parseInt(lastFour.slice(-2));
    const historicalBias = lastTwoDigits < 50 ? -1 : 1; // -1 for SMALL bias, 1 for BIG bias
    
    // Scoring System
    let smallScore = 0;
    let bigScore = 0;
    
    // Rule 1: Digit sum divisible by 3 favors SMALL
    if (digitSumMod3 === 0) smallScore += 2;
    
    // Rule 2: Digit sum divisible by 5 favors BIG
    if (digitSumMod5 === 0) bigScore += 2;
    
    // Rule 3: More even digits favors BIG
    if (evenDigits > oddDigits) bigScore += 1;
    else if (oddDigits > evenDigits) smallScore += 1;
    
    // Rule 4: Ascending sequence favors BIG
    if (ascendingCount >= 2) bigScore += 1;
    
    // Rule 5: Descending sequence favors SMALL
    if (descendingCount >= 2) smallScore += 1;
    
    // Rule 6: First and last digit difference
    if (firstLastDiff <= 2) smallScore += 1;
    else if (firstLastDiff >= 6) bigScore += 1;
    
    // Rule 7: Middle average
    if (middleAvg < 4.5) smallScore += 1;
    else if (middleAvg > 4.5) bigScore += 1;
    
    // Rule 8: Historical bias
    if (historicalBias === -1) smallScore += 1;
    else bigScore += 1;
    
    // Calculate confidence
    const totalScore = smallScore + bigScore;
    currentConfidence = totalScore > 0 ? (Math.max(smallScore, bigScore) / totalScore) * 100 : 50;
    
    // Determine prediction with explanation
    let prediction, explanation;
    if (smallScore > bigScore) {
      prediction = 'SMALL';
      explanation = `AI detected ${smallScore} small indicators vs ${bigScore} big indicators`;
    } else if (bigScore > smallScore) {
      prediction = 'BIG';
      explanation = `AI detected ${bigScore} big indicators vs ${smallScore} small indicators`;
    } else {
      // Tiebreaker - use historical bias
      prediction = historicalBias === -1 ? 'SMALL' : 'BIG';
      explanation = `Even score (${smallScore}-${bigScore}), using historical bias`;
    }
    
    document.getElementById('pattern-info').textContent = explanation;
    document.getElementById('confidence-value').textContent = currentConfidence.toFixed(0) + '%';
    document.getElementById('confidence-fill').style.width = currentConfidence + '%';
    
    return prediction;
  }

  // ✅ Fetch Current Game Issue
  async function fetchCurrentGameIssue() {
    const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetGameIssue';
    const requestData = {
      typeId: 1,
      language: 0,
      random: "40079dcba93a48769c6ee9d4d4fae23f",
      signature: "D12108C4F57C549D82B23A91E0FA20AE",
      timestamp: 1727792520,
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json;charset=UTF-8' },
        body: JSON.stringify(requestData),
      });

      if (response.ok) {
        const data = await response.json();
        if (data.code === 0) {
          latestPeriod = data.data.issueNumber;
          document.getElementById('period-number').textContent = latestPeriod;
          fetchPreviousResults();
        }
      }
    } catch (error) {
      console.error("❌ Fetch error:", error);
    }
  }

  // ✅ Fetch Previous Results
  async function fetchPreviousResults() {
    const apiUrl = 'https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList';
    const requestData = {
      pageSize: 10,
      pageNo: 1,
      typeId: 1,
      language: 0,
      random: "c2505d9138da4e3780b2c2b34f2fb789",
      signature: "7D637E060DA35C0C6E28DC6D23D71BED",
      timestamp: 1727792520,
    };

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json;charset=UTF-8' },
        body: JSON.stringify(requestData),
      });

      if (response.ok) {
        const data = await response.json();
        if (data.code === 0 && data.data.list.length > 0) {
          previousResults = data.data.list;
          updateResults();
        }
      }
    } catch (error) {
      console.error("❌ Fetch error:", error);
    }
  }

  // ✅ Update Results with Enhanced AI Prediction
  async function updateResults() {
    if (latestPeriod) {
      latestResult = predictBasedOnPeriod(latestPeriod);
      document.getElementById('predicted-result').textContent = latestResult;
      updateHistory();
    }
  }

  // ✅ Update History with trophy shaking effect for WON and cross shaking for LOST
  function updateHistory() {
    const historyContainer = document.getElementById('history-list');
    historyContainer.innerHTML = '';

    const newHistoryEntry = {
      period: latestPeriod.toString().slice(-4),
      prediction: latestResult,
      status: "PENDING",
      actualResult: null,
      confidence: currentConfidence
    };

    if (!storedHistory.some(entry => entry.period === newHistoryEntry.period)) {
      storedHistory.unshift(newHistoryEntry);
    }

    // Check if we need to update the status of the previous prediction
    const prevPeriod = storedHistory[1];
    let shouldAnimateWin = false;
    let shouldAnimateLoss = false;
    
    if (prevPeriod && prevPeriod.status === "PENDING") {
      // Get the actual result from the previous period
      const actualNumber = previousResults[0]?.number;
      const actualResult = actualNumber <= 4 ? 'SMALL' : 'BIG';
      
      prevPeriod.actualResult = actualResult;
      prevPeriod.status = prevPeriod.prediction === actualResult ? "WON" : "LOST";
      
      // Update accuracy metrics
      if (prevPeriod.status === "WON") {
        correctPredictions++;
        shouldAnimateWin = true;
      } else {
        shouldAnimateLoss = true;
      }
      totalPredictions++;
      
      // Update streak counter
      if (prevPeriod.status === "WON") {
        if (streakType === 'win') {
          currentStreak++;
        } else {
          currentStreak = 1;
          streakType = 'win';
        }
      } else {
        if (streakType === 'loss') {
          currentStreak++;
        } else {
          currentStreak = 1;
          streakType = 'loss';
        }
      }
    }

    // Update accuracy display
    const accuracy = totalPredictions > 0 ? (correctPredictions / totalPredictions) * 100 : 0;
    document.getElementById('accuracy-value').textContent = accuracy.toFixed(2) + '%';
    document.getElementById('accuracy-fill').style.width = accuracy + '%';
    
    // Update streak display
    document.getElementById('current-streak').textContent = currentStreak + (streakType === 'win' ? 'W' : 'L');
    document.getElementById('current-streak').className = streakType === 'win' ? 
      'text-xl font-bold text-green-500' : 'text-xl font-bold text-red-500';

    let winCount = 0, lossCount = 0;
    storedHistory.slice(0, 10).forEach((entry, index) => {
      const box = document.createElement('div');
      box.className = `history-box text-center p-3 rounded-lg mb-2 ${
        entry.status === 'WON' ? 'bg-green-100 border-l-4 border-green-500' : 
        entry.status === 'LOST' ? 'bg-red-100 border-l-4 border-red-500' : 
        'bg-yellow-100 border-l-4 border-yellow-500'
      }`;

      // Add trophy icon with shake effect for WON entries
      const statusIcon = entry.status === 'WON' ? 
        `<span class="trophy-shake"><i class="fas fa-trophy text-yellow-500"></i></span>` :
        entry.status === 'LOST' ? '<span class="cross-shake"><i class="fas fa-times-circle text-red-500"></i></span>' : 
        '<i class="fas fa-clock text-yellow-500"></i>';

      // Alternative display for actual result
      const resultDisplay = entry.actualResult ? 
        `<div class="text-xs mt-1">
          <span class="font-semibold">Actual:</span> 
          <span class="${entry.actualResult === 'SMALL' ? 'text-blue-900' : 'text-purple-600'}">
            ${entry.actualResult}
          </span>
        </div>` : '';

      // Confidence display for pending predictions
      const confidenceDisplay = entry.status === 'PENDING' ? 
        `<div class="text-xs mt-1">
          <span class="font-semibold">Confidence:</span> 
          <span class="text-blue-600">${entry.confidence.toFixed(0)}%</span>
        </div>` : '';

      box.innerHTML = `
        <div class="flex flex-col">
          <div class="flex justify-between items-center">
            <p class="text-gray-600">Period: <span class="font-bold text-black">${entry.period}</span></p>
            <p class="text-gray-600">Prediction: <span class="font-bold ${
              entry.prediction === 'SMALL' ? 'text-blue-600' : 'text-purple-600'
            }">${entry.prediction}</span></p>
          </div>
          <div class="flex justify-between items-center mt-1">
            <p class="${entry.status === 'WON' ? 'text-green-600 font-bold' : 
              entry.status === 'LOST' ? 'text-red-600 font-bold' : 
              'text-yellow-600 font-bold'}">
              ${statusIcon} ${entry.status}
            </p>
            ${resultDisplay}
            ${confidenceDisplay}
          </div>
        </div>
      `;

      historyContainer.appendChild(box);

      if (entry.status === "WON") winCount++;
      else if (entry.status === "LOST") lossCount++;
    });

    localStorage.setItem("gameHistory", JSON.stringify(storedHistory.slice(0, 10)));

    document.getElementById('won-count').textContent = winCount;
    document.getElementById('lost-count').textContent = lossCount;
    document.getElementById('won-percentage').textContent = 
      (winCount + lossCount > 0) ? ((winCount / (winCount + lossCount)) * 100).toFixed(2) + "%" : "0%";

    // Trigger animations
    if (shouldAnimateWin) {
      const trophyElements = document.querySelectorAll('.trophy-shake');
      const winBoxes = document.querySelectorAll('.bg-green-100');
      if (trophyElements.length > 0 && winBoxes.length > 0) {
        trophyElements[0].classList.add('animate-shake');
        winBoxes[0].classList.add('pulse-win');
        setTimeout(() => {
          trophyElements[0].classList.remove('animate-shake');
          winBoxes[0].classList.remove('pulse-win');
        }, 1000);
      }
    } else if (shouldAnimateLoss) {
      const crossElements = document.querySelectorAll('.cross-shake');
      const lossBoxes = document.querySelectorAll('.bg-red-100');
      if (crossElements.length > 0 && lossBoxes.length > 0) {
        crossElements[0].classList.add('animate-shake');
        lossBoxes[0].classList.add('pulse-loss');
        setTimeout(() => {
          crossElements[0].classList.remove('animate-shake');
          lossBoxes[0].classList.remove('pulse-loss');
        }, 1000);
      }
    }
  }

  // Initialize and start the process
  (function init() {
    // Load accuracy data from localStorage if available
    const savedAccuracy = JSON.parse(localStorage.getItem("accuracyData")) || {total: 0, correct: 0};
    totalPredictions = savedAccuracy.total;
    correctPredictions = savedAccuracy.correct;
    
    // ✅ Auto-Fetch Every 5 Seconds
    setInterval(fetchCurrentGameIssue, 5000);
    fetchCurrentGameIssue();
    
    // Save accuracy data before unload
    window.addEventListener('beforeunload', () => {
      localStorage.setItem("accuracyData", JSON.stringify({
        total: totalPredictions,
        correct: correctPredictions
      }));
    });
  })();
  </script>
</body>
</html>
